(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{3260:(function(z,K,U){var V=Object.defineProperty,D=Object.getOwnPropertyDescriptor,S=Object.getOwnPropertyNames,G=Object.prototype.hasOwnProperty,N=(x,s)=>{for(var e in s)V(x,e,{get:s[e],enumerable:!0})},E=(x,s,e,o)=>{if(s&&typeof s=="object"||typeof s=="function")for(let t of S(s))!G.call(x,t)&&t!==e&&V(x,t,{get:()=>s[t],enumerable:!(o=D(s,t))||o.enumerable});return x},J=x=>E(V({},"__esModule",{value:!0}),x),F={};N(F,{OBJLoader:()=>W}),z.exports=J(F);var n=U(1899);const k=/^[og]\s*(.+)?/,R=/^mtllib /,H=/^usemtl /,T=/^usemap /,A=/\s+/,I=new n.Vector3,P=new n.Vector3,O=new n.Vector3,C=new n.Vector3,j=new n.Vector3,L=new n.Color;function q(){const x={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(s,e){if(this.object&&this.object.fromDeclaration===!1){this.object.name=s,this.object.fromDeclaration=e!==!1;return}const o=this.object&&typeof this.object.currentMaterial=="function"?this.object.currentMaterial():void 0;if(this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0),this.object={name:s||"",fromDeclaration:e!==!1,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(t,i){const l=this._finalize(!1);l&&(l.inherited||l.groupCount<=0)&&this.materials.splice(l.index,1);const d={index:this.materials.length,name:t||"",mtllib:Array.isArray(i)&&i.length>0?i[i.length-1]:"",smooth:l!==void 0?l.smooth:this.smooth,groupStart:l!==void 0?l.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(b){const a={index:typeof b=="number"?b:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return a.clone=this.clone.bind(a),a}};return this.materials.push(d),d},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(t){const i=this.currentMaterial();if(i&&i.groupEnd===-1&&(i.groupEnd=this.geometry.vertices.length/3,i.groupCount=i.groupEnd-i.groupStart,i.inherited=!1),t&&this.materials.length>1)for(let l=this.materials.length-1;l>=0;l--)this.materials[l].groupCount<=0&&this.materials.splice(l,1);return t&&this.materials.length===0&&this.materials.push({name:"",smooth:this.smooth}),i}},o&&o.name&&typeof o.clone=="function"){const t=o.clone(0);t.inherited=!0,this.object.materials.push(t)}this.objects.push(this.object)},finalize:function(){this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0)},parseVertexIndex:function(s,e){const o=parseInt(s,10);return(o>=0?o-1:o+e/3)*3},parseNormalIndex:function(s,e){const o=parseInt(s,10);return(o>=0?o-1:o+e/3)*3},parseUVIndex:function(s,e){const o=parseInt(s,10);return(o>=0?o-1:o+e/2)*2},addVertex:function(s,e,o){const t=this.vertices,i=this.object.geometry.vertices;i.push(t[s+0],t[s+1],t[s+2]),i.push(t[e+0],t[e+1],t[e+2]),i.push(t[o+0],t[o+1],t[o+2])},addVertexPoint:function(s){const e=this.vertices;this.object.geometry.vertices.push(e[s+0],e[s+1],e[s+2])},addVertexLine:function(s){const e=this.vertices;this.object.geometry.vertices.push(e[s+0],e[s+1],e[s+2])},addNormal:function(s,e,o){const t=this.normals,i=this.object.geometry.normals;i.push(t[s+0],t[s+1],t[s+2]),i.push(t[e+0],t[e+1],t[e+2]),i.push(t[o+0],t[o+1],t[o+2])},addFaceNormal:function(s,e,o){const t=this.vertices,i=this.object.geometry.normals;I.fromArray(t,s),P.fromArray(t,e),O.fromArray(t,o),j.subVectors(O,P),C.subVectors(I,P),j.cross(C),j.normalize(),i.push(j.x,j.y,j.z),i.push(j.x,j.y,j.z),i.push(j.x,j.y,j.z)},addColor:function(s,e,o){const t=this.colors,i=this.object.geometry.colors;t[s]!==void 0&&i.push(t[s+0],t[s+1],t[s+2]),t[e]!==void 0&&i.push(t[e+0],t[e+1],t[e+2]),t[o]!==void 0&&i.push(t[o+0],t[o+1],t[o+2])},addUV:function(s,e,o){const t=this.uvs,i=this.object.geometry.uvs;i.push(t[s+0],t[s+1]),i.push(t[e+0],t[e+1]),i.push(t[o+0],t[o+1])},addDefaultUV:function(){const s=this.object.geometry.uvs;s.push(0,0),s.push(0,0),s.push(0,0)},addUVLine:function(s){const e=this.uvs;this.object.geometry.uvs.push(e[s+0],e[s+1])},addFace:function(s,e,o,t,i,l,d,b,a){const u=this.vertices.length;let r=this.parseVertexIndex(s,u),c=this.parseVertexIndex(e,u),f=this.parseVertexIndex(o,u);if(this.addVertex(r,c,f),this.addColor(r,c,f),d!==void 0&&d!==""){const m=this.normals.length;r=this.parseNormalIndex(d,m),c=this.parseNormalIndex(b,m),f=this.parseNormalIndex(a,m),this.addNormal(r,c,f)}else this.addFaceNormal(r,c,f);if(t!==void 0&&t!==""){const m=this.uvs.length;r=this.parseUVIndex(t,m),c=this.parseUVIndex(i,m),f=this.parseUVIndex(l,m),this.addUV(r,c,f),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(s){this.object.geometry.type="Points";const e=this.vertices.length;for(let o=0,t=s.length;o<t;o++){const i=this.parseVertexIndex(s[o],e);this.addVertexPoint(i),this.addColor(i)}},addLineGeometry:function(s,e){this.object.geometry.type="Line";const o=this.vertices.length,t=this.uvs.length;for(let i=0,l=s.length;i<l;i++)this.addVertexLine(this.parseVertexIndex(s[i],o));for(let i=0,l=e.length;i<l;i++)this.addUVLine(this.parseUVIndex(e[i],t))}};return x.startObject("",!1),x}class W extends n.Loader{constructor(s){super(s),this.materials=null}load(s,e,o,t){const i=this,l=new n.FileLoader(this.manager);l.setPath(this.path),l.setRequestHeader(this.requestHeader),l.setWithCredentials(this.withCredentials),l.load(s,function(d){try{e(i.parse(d))}catch(b){t?t(b):console.error(b),i.manager.itemError(s)}},o,t)}setMaterials(s){return this.materials=s,this}parse(s){const e=new q;s.indexOf(`\r
`)!==-1&&(s=s.replace(/\r\n/g,`
`)),s.indexOf(`\\
`)!==-1&&(s=s.replace(/\\\n/g,""));const o=s.split(`
`);let t=[];for(let d=0,b=o.length;d<b;d++){const a=o[d].trimStart();if(a.length===0)continue;const u=a.charAt(0);if(u!=="#")if(u==="v"){const r=a.split(A);switch(r[0]){case"v":e.vertices.push(parseFloat(r[1]),parseFloat(r[2]),parseFloat(r[3])),r.length>=7?(L.setRGB(parseFloat(r[4]),parseFloat(r[5]),parseFloat(r[6]),n.SRGBColorSpace),e.colors.push(L.r,L.g,L.b)):e.colors.push(void 0,void 0,void 0);break;case"vn":e.normals.push(parseFloat(r[1]),parseFloat(r[2]),parseFloat(r[3]));break;case"vt":e.uvs.push(parseFloat(r[1]),parseFloat(r[2]));break}}else if(u==="f"){const c=a.slice(1).trim().split(A),f=[];for(let h=0,g=c.length;h<g;h++){const v=c[h];if(v.length>0){const y=v.split("/");f.push(y)}}const m=f[0];for(let h=1,g=f.length-1;h<g;h++){const v=f[h],y=f[h+1];e.addFace(m[0],v[0],y[0],m[1],v[1],y[1],m[2],v[2],y[2])}}else if(u==="l"){const r=a.substring(1).trim().split(" ");let c=[];const f=[];if(a.indexOf("/")===-1)c=r;else for(let m=0,h=r.length;m<h;m++){const g=r[m].split("/");g[0]!==""&&c.push(g[0]),g[1]!==""&&f.push(g[1])}e.addLineGeometry(c,f)}else if(u==="p"){const c=a.slice(1).trim().split(" ");e.addPointGeometry(c)}else if((t=k.exec(a))!==null){const r=(" "+t[0].slice(1).trim()).slice(1);e.startObject(r)}else if(H.test(a))e.object.startMaterial(a.substring(7).trim(),e.materialLibraries);else if(R.test(a))e.materialLibraries.push(a.substring(7).trim());else if(T.test(a))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if(u==="s"){if(t=a.split(" "),t.length>1){const c=t[1].trim().toLowerCase();e.object.smooth=c!=="0"&&c!=="off"}else e.object.smooth=!0;const r=e.object.currentMaterial();r&&(r.smooth=e.object.smooth)}else{if(a==="\0")continue;console.warn('THREE.OBJLoader: Unexpected line: "'+a+'"')}}e.finalize();const i=new n.Group;if(i.materialLibraries=[].concat(e.materialLibraries),!(e.objects.length===1&&e.objects[0].geometry.vertices.length===0)===!0)for(let d=0,b=e.objects.length;d<b;d++){const a=e.objects[d],u=a.geometry,r=a.materials,c=u.type==="Line",f=u.type==="Points";let m=!1;if(u.vertices.length===0)continue;const h=new n.BufferGeometry;h.setAttribute("position",new n.Float32BufferAttribute(u.vertices,3)),u.normals.length>0&&h.setAttribute("normal",new n.Float32BufferAttribute(u.normals,3)),u.colors.length>0&&(m=!0,h.setAttribute("color",new n.Float32BufferAttribute(u.colors,3))),u.hasUVIndices===!0&&h.setAttribute("uv",new n.Float32BufferAttribute(u.uvs,2));const g=[];for(let y=0,M=r.length;y<M;y++){const _=r[y],B=_.name+"_"+_.smooth+"_"+m;let p=e.materials[B];if(this.materials!==null){if(p=this.materials.create(_.name),c&&p&&!(p instanceof n.LineBasicMaterial)){const w=new n.LineBasicMaterial;n.Material.prototype.copy.call(w,p),w.color.copy(p.color),p=w}else if(f&&p&&!(p instanceof n.PointsMaterial)){const w=new n.PointsMaterial({size:10,sizeAttenuation:!1});n.Material.prototype.copy.call(w,p),w.color.copy(p.color),w.map=p.map,p=w}}p===void 0&&(c?p=new n.LineBasicMaterial:f?p=new n.PointsMaterial({size:1,sizeAttenuation:!1}):p=new n.MeshPhongMaterial,p.name=_.name,p.flatShading=!_.smooth,p.vertexColors=m,e.materials[B]=p),g.push(p)}let v;if(g.length>1){for(let y=0,M=r.length;y<M;y++){const _=r[y];h.addGroup(_.groupStart,_.groupCount,y)}c?v=new n.LineSegments(h,g):f?v=new n.Points(h,g):v=new n.Mesh(h,g)}else c?v=new n.LineSegments(h,g[0]):f?v=new n.Points(h,g[0]):v=new n.Mesh(h,g[0]);v.name=a.name,i.add(v)}else if(e.vertices.length>0){const d=new n.PointsMaterial({size:1,sizeAttenuation:!1}),b=new n.BufferGeometry;b.setAttribute("position",new n.Float32BufferAttribute(e.vertices,3)),e.colors.length>0&&e.colors[0]!==void 0&&(b.setAttribute("color",new n.Float32BufferAttribute(e.colors,3)),d.vertexColors=!0);const a=new n.Points(b,d);i.add(a)}return i}}})}]);
