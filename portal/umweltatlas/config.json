import json
import copy
import urllib.request
import csv
import re
import fmeobjects

# ==========================
# CONFIG
# ==========================

# Umweltatlas Masterportal config (tree target)
CONFIG_URL = "https://ua-map.netlify.app/umweltatlas/config.json"

# Geoportal Berlin main config (for layer id -> name lookup)
LAYER_CONFIG_URL = "https://gdi.berlin.de/viewer/main/config.json"

OUTPUT_CONFIG_FILE = r"config.generated.json"      # adjust path if needed
CSV_FILE = "sitemap-karten.csv"                    # same folder as workspace

MAX_ID_COLS = 20


# ==========================
# HELPERS: HTTP + JSON
# ==========================

def fetch_json_from_url(url):
    req = urllib.request.Request(url, headers={"User-Agent": "FME-PythonCreator"})
    with urllib.request.urlopen(req, timeout=60) as resp:
        charset = resp.headers.get_content_charset() or "utf-8"
        data = resp.read().decode(charset, errors="ignore")
    return json.loads(data)


def _node_label(node):
    """
    Try to get a human-readable label from a node dict.
    In the subjectlayer tree this is always 'name'.
    """
    if not isinstance(node, dict):
        return None
    val = node.get("name")
    if isinstance(val, str):
        return val.strip()
    return None


# ==========================
# STEP 0: BUILD id -> name INDEX FROM GEOPORTAL CONFIG
# ==========================

def build_layer_name_index(obj, index):
    """
    Recursively walk the Geoportal config JSON and collect
    all entries with string 'id' and 'name' into index[id] = name.
    """
    if isinstance(obj, dict):
        lid = obj.get("id")
        lname = obj.get("name")
        if isinstance(lid, str) and isinstance(lname, str):
            index[lid] = lname
        for v in obj.values():
            if isinstance(v, (dict, list)):
                build_layer_name_index(v, index)

    elif isinstance(obj, list):
        for item in obj:
            if isinstance(item, (dict, list)):
                build_layer_name_index(item, index)


# ==========================
# STEP 1: REMOVE BODEN..ENERGIE IN SUBJECTLAYER
# ==========================

def cut_boden_to_energie_in_subjects(subjects):
    """
    subjects: list of root subject nodes under layerConfig.subjectlayer.elements.
    Remove everything from 'Boden' to 'Energie' (inclusive), by label.
    """
    if not isinstance(subjects, list):
        return False

    start_idx = None
    end_idx = None

    for i, n in enumerate(subjects):
        label = _node_label(n)
        if not label:
            continue
        low = label.lower()
        if low == "boden" and start_idx is None:
            start_idx = i
        if low == "energie":
            end_idx = i

    if start_idx is not None and end_idx is not None and end_idx >= start_idx:
        del subjects[start_idx:end_idx + 1]
        return True

    return False


# ==========================
# STEP 2: CSV -> FULL TREE (THEMA/SUBTHEMA/YEAR/TITLE/LAYER)
# ==========================

def _safe_int_or_str(y):
    """Helper to sort years numerically when possible, else by string."""
    y = (y or "").strip()
    try:
        return int(y)
    except ValueError:
        return y


def _extract_layer_id(raw_id):
    """
    CSV id_* columns contain strings like:
        "id":"ua_boden_naturnaehe_2015:a_naturnaehe2015"
    Extract the ID value.
    """
    if not raw_id:
        return ""
    txt = raw_id.strip()
    m = re.search(r'"id"\s*:\s*"([^"]+)"', txt)
    if m:
        return m.group(1).strip()
    return txt


def _clean_layer_name_from_index(base_name, year, fallback_title):
    """
    Build final layer name from Geoportal config name:
      - start with base_name (from id -> name index)
      - if empty, use fallback_title
      - remove ALL occurrences of year everywhere in the string
      - remove leading numbering like '01.11.9 ' from the start
      - remove trailing map numbers like '1', '2', '03'
      - clean up leftover brackets, dashes, spaces
      - final result: '<year> - <cleaned name>'
    """

    base = (base_name or "").strip()
    if not base:
        base = (fallback_title or "").strip()

    if not base:
        return year or ""

    year = (year or "").strip()

    if year:
        # Remove any occurrence of the year in various formats
        base = re.sub(
            rf"[\s\-\(\[\{{\/]*{re.escape(year)}[\s\-\)\]\}}\/]*",
            "",
            base,
            flags=re.IGNORECASE
        )

    # Remove leading numbering like '01.11.9 ' or '1.2 '
    base = re.sub(r"^\s*\d+(?:\.\d+)*\s+", "", base)

    # Remove trailing map numbering (e.g. " 1", " 2", " 03", " 05")
    base = re.sub(r"[\s\-\(\[]*\d{1,2}[\s\-\)\]]*$", "", base)

    # Remove leftover "()", "[]", "--", multiple spaces
    base = re.sub(r"\(\s*\)", "", base)
    base = re.sub(r"\[\s*\]", "", base)
    base = re.sub(r"\s{2,}", " ", base)
    base = re.sub(r"\s*-\s*$", "", base)

    base = base.strip(" -–,;")

    # Final: prefix year
    if year:
        return f"{year} - {base}"
    else:
        return base


def build_thema_folders_from_csv(csv_path, layer_name_index):
    """
    Read sitemap-karten.csv and create:
      - one folder per unique 'thema'
      - inside each thema, folders for 'subthema'
      - inside each subthema, folders for 'year'
      - inside each year, folders for 'title'
      - inside each title, leaf layer objects with "id" and "name"

    Only rows with keine_karte != 'x' are used.
    """

    # themen[thema][subthema][year][title] = { "layers": {layer_id: layer_name, ...} }
    themen = {}

    with open(csv_path, "r", encoding="utf-8-sig", newline="") as f:
        reader = csv.DictReader(f, delimiter=";")
        for row in reader:
            thema = (row.get("thema") or "").strip()
            subthema = (row.get("subthema") or "").strip()
            year = (row.get("year") or "").strip()
            title = (row.get("title") or "").strip()

            if not thema or not subthema or not year or not title:
                continue

            keine_karte_raw = (row.get("keine_karte") or "").strip().lower()
            has_map = not (keine_karte_raw == "x")
            if not has_map:
                # ignore rows without a map
                continue

            # ensure nested structure exists
            themen.setdefault(thema, {})
            themen[thema].setdefault(subthema, {})
            themen[thema][subthema].setdefault(year, {})
            entry = themen[thema][subthema][year].setdefault(title, {"layers": {}})

            # check id_1 .. id_20
            for idx in range(1, MAX_ID_COLS + 1):
                raw_id = (row.get(f"id_{idx}") or "").strip()
                if not raw_id:
                    continue

                layer_id = _extract_layer_id(raw_id)
                if not layer_id:
                    continue

                # layer base name from Geoportal config
                base_name = layer_name_index.get(layer_id, "")

                layer_name = _clean_layer_name_from_index(base_name, year, title)

                # avoid duplicates
                if layer_id not in entry["layers"]:
                    entry["layers"][layer_id] = layer_name

    thema_nodes = []

    # Build Masterportal-style tree: name/type/elements
    for thema in sorted(themen.keys(), key=lambda s: s.lower()):
        sub_map = themen[thema]

        thema_node = {
            "name": thema,
            "type": "folder",
            "elements": []
        }

        for sub in sorted(sub_map.keys(), key=lambda s: s.lower()):
            year_map = sub_map[sub]

            # keep only years with at least one title having at least one layer
            valid_years = []
            for y, titles_dict in year_map.items():
                if any(len(entry["layers"]) > 0 for entry in titles_dict.values()):
                    valid_years.append(y)

            if not valid_years:
                continue

            sub_node = {
                "name": sub,
                "type": "folder",
                "elements": []
            }

            # year folders sorted newest → oldest
            for y in sorted(valid_years, key=_safe_int_or_str, reverse=True):
                titles_dict = year_map[y]

                year_node = {
                    "name": y,
                    "type": "folder",
                    "elements": []
                }

                # titles sorted alphabetically
                for t in sorted(titles_dict.keys(), key=lambda s: s.lower()):
                    entry = titles_dict[t]
                    layers_dict = entry["layers"]

                    if not layers_dict:
                        continue

                    title_node = {
                        "name": t,
                        "type": "folder",
                        "elements": []
                    }

                    # layer elements: id + name
                    for lid, lname in sorted(layers_dict.items(), key=lambda kv: kv[1].lower()):
                        layer_node = {
                            "id": lid,
                            "name": lname
                        }
                        title_node["elements"].append(layer_node)

                    if title_node["elements"]:
                        year_node["elements"].append(title_node)

                if year_node["elements"]:
                    sub_node["elements"].append(year_node)

            if sub_node["elements"]:
                thema_node["elements"].append(sub_node)

        thema_nodes.append(thema_node)

    return thema_nodes


# ==========================
# STEP 3: INSERT THEMEN BEFORE "LUFTBILDER" IN SUBJECTLAYER
# ==========================

def insert_themen_before_luftbilder_in_subjects(subjects, thema_nodes):
    """
    subjects: list (layerConfig.subjectlayer.elements)
    Insert thema_nodes BEFORE the subject with label 'Luftbilder'.
    If 'Luftbilder' is not found, append to the end.
    """
    if not isinstance(subjects, list):
        return False

    insert_index = None
    for i, n in enumerate(subjects):
        label = _node_label(n)
        if label and label.strip().lower() == "luftbilder":
            insert_index = i
            break

    if insert_index is None:
        subjects.extend(copy.deepcopy(thema_nodes))
    else:
        subjects[insert_index:insert_index] = copy.deepcopy(thema_nodes)

    return True


# ==========================
# FME PYTHON CREATOR
# ==========================

class FeatureCreator(object):
    def __init__(self):
        pass

    def input(self, feature):
        # No incoming features needed for this job
        pass

    def close(self):
        # 1) Download original Umweltatlas config (target)
        base_config = fetch_json_from_url(CONFIG_URL)

        # 2) Download Geoportal config and build id -> name index
        try:
            geoportal_config = fetch_json_from_url(LAYER_CONFIG_URL)
            layer_name_index = {}
            build_layer_name_index(geoportal_config, layer_name_index)
            index_size = len(layer_name_index)
        except Exception as e:
            layer_name_index = {}
            index_size = 0
            print("[WARN] Failed to load Geoportal config or build index:", e)

        # 3) Deep copy UA config
        new_config = copy.deepcopy(base_config)

        # 4) Get subjectlayer elements (this is where Boden/Wasser/Luftbilder live)
        layer_cfg = new_config.get("layerConfig")
        if not isinstance(layer_cfg, dict):
            layer_cfg = {}
            new_config["layerConfig"] = layer_cfg

        subj_layer = layer_cfg.setdefault("subjectlayer", {})
        subjects = subj_layer.get("elements")

        if not isinstance(subjects, list):
            subjects = []
            subj_layer["elements"] = subjects

        # 5) Remove tree structure from 'Boden' to 'Energie'
        cut_done = cut_boden_to_energie_in_subjects(subjects)

        # 6) Build full Thema→Subthema→Year→Title→Layer tree from CSV
        try:
            thema_nodes = build_thema_folders_from_csv(CSV_FILE, layer_name_index)
            thema_count = len(thema_nodes)
            subthema_count = sum(len(t["elements"]) for t in thema_nodes)
            year_count = sum(
                len(sub["elements"])
                for t in thema_nodes
                for sub in t["elements"]
            )
            title_count = sum(
                len(year["elements"])
                for t in thema_nodes
                for sub in t["elements"]
                for year in sub["elements"]
            )
            layer_count = sum(
                len(title["elements"])
                for t in thema_nodes
                for sub in t["elements"]
                for year in sub["elements"]
                for title in year["elements"]
            )
        except Exception as e:
            thema_nodes = []
            thema_count = 0
            subthema_count = 0
            year_count = 0
            title_count = 0
            layer_count = 0
            print("[WARN] Failed to read or parse CSV:", e)

        # 7) Insert thema folders before 'Luftbilder' in subjects
        insert_done = False
        if thema_nodes:
            insert_done = insert_themen_before_luftbilder_in_subjects(subjects, thema_nodes)

        # 8) Write new config JSON to file
        with open(OUTPUT_CONFIG_FILE, "w", encoding="utf-8") as f:
            json.dump(new_config, f, ensure_ascii=False, indent=2)

        # 9) Output info feature
        feat = fmeobjects.FMEFeature()
        feat.setAttribute("config_source_url", CONFIG_URL)
        feat.setAttribute("layer_config_source_url", LAYER_CONFIG_URL)
        feat.setAttribute("config_output_file", OUTPUT_CONFIG_FILE)
        feat.setAttribute("boden_energie_cut_done", "Yes" if cut_done else "No")
        feat.setAttribute("id_name_index_size", index_size)
        feat.setAttribute("thema_folder_count", thema_count)
        feat.setAttribute("subthema_folder_count", subthema_count)
        feat.setAttribute("year_folder_count", year_count)
        feat.setAttribute("title_folder_count", title_count)
        feat.setAttribute("layer_count", layer_count)
        feat.setAttribute("thema_insert_done", "Yes" if insert_done else "No")
        self.pyoutput(feat)
